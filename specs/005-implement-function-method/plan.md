# Implementation Plan: Intelligent Code Chunking for Granular Indexing

**Branch**: `005-implement-function-method` | **Date**: 2025-10-13 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/005-implement-function-method/spec.md`

**Note**: This plan is generated by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Implement function/method-level code chunking that breaks down source files into logical units centered around functions and methods. Each chunk includes leading documentation, enclosing context (class/module), and a stable content-based hash ID. Supports TypeScript, JavaScript, and Python with language-specific queries. Enables more precise search results by indexing at function granularity rather than file level.

## Technical Context

**Language/Version**: TypeScript 5.x / Node.js 20+
**Primary Dependencies**: tree-sitter, tree-sitter-javascript, tree-sitter-typescript, tree-sitter-python, @node-rs/xxhash (already installed)
**Storage**: SQLite via better-sqlite3 (extend existing schema with chunks table)
**Testing**: Vitest (existing test infrastructure)
**Target Platform**: Node.js CLI (cross-platform: macOS, Linux, Windows)
**Project Type**: Single CLI project (extends existing code-index tool)
**Performance Goals**: 10,000 functions/minute chunking, <100ms query response for 1M chunks
**Constraints**: <200MB memory for 100k functions, 100% chunk ID stability for whitespace-only changes
**Scale/Scope**: Support codebases up to 1M chunks, 3 languages (TS/JS/Python), 9 chunk types

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Note**: Project constitution is using template placeholders. Applying standard best practices gates:

✅ **Library-First**: Chunking functionality will be implemented as standalone service in `src/services/chunker/`
✅ **Testing**: TDD mandatory - tests written before implementation
✅ **Simplicity**: Extends existing Tree-sitter parser infrastructure - minimal new abstractions
✅ **Performance**: Measurable success criteria defined (SC-001 through SC-010)
✅ **Integration**: Builds on existing parser services (TreeSitterParser, SymbolExtractor)

**Gate Status**: PASSED - No constitution violations

## Project Structure

### Documentation (this feature)

```
specs/005-implement-function-method/
├── spec.md              # Feature specification (complete with clarifications)
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output (to be generated)
├── data-model.md        # Phase 1 output (to be generated)
├── quickstart.md        # Phase 1 output (to be generated)
├── contracts/           # Phase 1 output (to be generated)
│   └── chunker-api.ts   # TypeScript interface definitions
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)

```
src/
├── models/
│   ├── Chunk.ts                 # NEW: Chunk entity model
│   ├── ChunkMetadata.ts         # NEW: Chunk metadata model
│   └── ChunkQuery.ts            # NEW: Query model for chunk retrieval
├── services/
│   ├── parser/                  # EXISTING: Tree-sitter infrastructure
│   │   ├── TreeSitterParser.ts  # Base parser (EXTEND for chunk extraction)
│   │   ├── SymbolExtractor.ts   # Symbol extraction (REUSE)
│   │   ├── CommentExtractor.ts  # Comment extraction (REUSE)
│   │   ├── HashGenerator.ts     # Hash generation (REUSE)
│   │   └── LanguageLoader.ts    # Language loading (REUSE)
│   ├── chunker/                 # NEW: Chunking services
│   │   ├── CodeChunker.ts       # Main chunking orchestrator
│   │   ├── FunctionExtractor.ts # Extract function/method nodes
│   │   ├── ContextExtractor.ts  # Extract class/module context
│   │   ├── DocumentationLinker.ts # Link docs to code
│   │   ├── ChunkHasher.ts       # Generate stable chunk IDs
│   │   └── index.ts             # Public API exports
│   └── database/                # EXISTING: Database services
│       └── ChunkRepository.ts   # NEW: Chunk CRUD operations
├── cli/
│   └── commands/
│       └── chunk.ts             # NEW: CLI command for chunking (optional, for testing)
└── lib/
    └── queries/                 # NEW: Language-specific Tree-sitter queries
        ├── typescript.scm       # TS function/method queries
        ├── javascript.scm       # JS function/method queries
        └── python.scm           # Python function/method queries

tests/
├── unit/
│   ├── services/
│   │   └── chunker/            # NEW: Unit tests for chunking services
│   │       ├── CodeChunker.test.ts
│   │       ├── FunctionExtractor.test.ts
│   │       ├── ContextExtractor.test.ts
│   │       ├── DocumentationLinker.test.ts
│   │       └── ChunkHasher.test.ts
│   └── models/
│       └── Chunk.test.ts       # NEW: Chunk model tests
├── integration/
│   └── chunker/                # NEW: Integration tests
│       ├── typescript-chunking.test.ts
│       ├── javascript-chunking.test.ts
│       ├── python-chunking.test.ts
│       └── chunk-stability.test.ts
└── fixtures/                   # NEW: Test source files
    ├── typescript/
    ├── javascript/
    └── python/
```

**Structure Decision**: Single project structure (Option 1) selected because this is a CLI tool with no frontend/backend split. Chunking functionality extends the existing `src/services/` architecture, leveraging the Tree-sitter parser infrastructure already in place from feature 004-integrate-tree-sitter. New chunker services will be co-located with existing parser services for cohesion.

## Complexity Tracking

*No constitution violations identified - this section intentionally left empty.*

## Phase 0: Research & Technology Decisions

**Status**: To be generated in `research.md`

**Research Areas**:
1. Tree-sitter query patterns for function/method extraction across TS/JS/Python
2. Whitespace normalization strategies for stable hashing
3. Context extraction patterns (class inheritance, module paths, namespaces)
4. Chunk type detection patterns for 9 types (function, method, constructor, property, class, module, async_function, async_method, generator)
5. Documentation association heuristics (leading comments, JSDoc, docstrings)
6. Large function handling strategies (5,000+ line warning thresholds)
7. SQLite schema design for chunk storage and querying
8. Query optimization for language-specific and type-based filtering

## Phase 1: Design Artifacts

**Status**: To be generated

**Artifacts**:
1. `data-model.md` - Chunk entity definitions, relationships, and SQLite schema
2. `contracts/chunker-api.ts` - TypeScript interfaces for chunking services
3. `quickstart.md` - User-facing documentation for chunking feature

## Phase 2: Task Breakdown

**Status**: Generated by `/speckit.tasks` command (not part of this plan)

---

## Implementation Notes

### Integration Points

1. **Extends Feature 004** (Tree-sitter Integration):
   - Reuses `TreeSitterParser`, `LanguageLoader`, `HashGenerator`
   - Leverages existing language parser setup
   - Adds new query files for function/method extraction

2. **Database Extension**:
   - New `chunks` table with foreign key to existing `files` table
   - Indexes on: chunk_type, language, chunk_hash, file_id
   - FTS5 virtual table for chunk content search

3. **Indexing Pipeline**:
   - File indexing → Parse AST → Extract chunks → Store chunks
   - Incremental update: detect changed files → rechunk → update DB

### Key Technical Decisions

1. **Chunking Strategy**: Top-level functions and methods only; nested functions stay with parent
2. **Hash Normalization**: Whitespace only (documentation content changes trigger new IDs)
3. **Context Inclusion**: Names + signatures (class name, inheritance, method signature, module path)
4. **Chunk Type Taxonomy**: 9 types recognized (function, method, constructor, property, class, module, async_function, async_method, generator)
5. **Large Function Handling**: No hard limit, warning logged for functions >5,000 lines

### Success Criteria Validation

- **SC-001**: 10,000 functions/minute → Validate with performance tests on large codebases
- **SC-002**: 100% identical content → same chunk ID → Validate with hash stability tests
- **SC-003**: 100% whitespace-only stability → Validate with normalization tests
- **SC-006**: <200MB for 100k functions → Validate with memory profiling
- **SC-010**: <100ms queries for 1M chunks → Validate with database query benchmarks

